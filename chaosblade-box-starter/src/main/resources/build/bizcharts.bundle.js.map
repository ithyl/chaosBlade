{"version":3,"file":"bizcharts.bundle.js","sources":["../../src/polar.js"],"sourcesContent":["/**\n * @fileOverview the class of Polar Coordinate\n * @author sima.zhang\n */\nconst MatrixUtil = require('@antv/util/lib/matrix/');\nconst isNumberEqual = require('@antv/util/lib/math/is-number-equal');\nconst mix = require('@antv/util/lib/mix');\nconst Base = require('./base');\n\nconst mat3 = MatrixUtil.mat3;\nconst vec2 = MatrixUtil.vec2;\nconst vec3 = MatrixUtil.vec3;\n\nclass Polar extends Base {\n\n  getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return mix({}, cfg, {\n      startAngle: -Math.PI / 2,\n      endAngle: Math.PI * 3 / 2,\n      innerRadius: 0,\n      type: 'polar',\n      isPolar: true\n    });\n  }\n\n  constructor(cfg) {\n    super(cfg);\n    this._init();\n  }\n\n  _init() {\n    let radius = this.radius;\n    const innerRadius = this.innerRadius;\n    const center = this.center;\n    const startAngle = this.startAngle;\n\n    let endAngle = this.endAngle;\n    while (endAngle < startAngle) {\n      endAngle += (Math.PI * 2);\n    }\n    this.endAngle = endAngle;\n    const oneBox = this.getOneBox();\n\n    const oneWidth = oneBox.maxX - oneBox.minX;\n    const oneHeight = oneBox.maxY - oneBox.minY;\n    const left = Math.abs(oneBox.minX) / oneWidth;\n    const top = Math.abs(oneBox.minY) / oneHeight;\n    const width = this.width;\n    const height = this.height;\n    let maxRadius;\n    let circleCentre;\n    if ((height / oneHeight) > (width / oneWidth)) { // width为主\n      maxRadius = width / oneWidth;\n      circleCentre = {\n        x: center.x - (0.5 - left) * width,\n        y: center.y - (0.5 - top) * maxRadius * oneHeight\n      };\n    } else { // height为主\n      maxRadius = height / oneHeight;\n      circleCentre = {\n        x: center.x - (0.5 - left) * maxRadius * oneWidth,\n        y: center.y - (0.5 - top) * height\n      };\n    }\n\n    if (!radius) {\n      radius = maxRadius;\n    } else if (radius > 0 && radius <= 1) {\n      radius = maxRadius * radius;\n    } else if (radius <= 0 || radius > maxRadius) {\n      radius = maxRadius;\n    }\n\n    const x = {\n      start: startAngle,\n      end: endAngle\n    };\n\n    const y = {\n      start: innerRadius * radius,\n      end: radius\n    };\n\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.circleCentre = circleCentre;\n    this.center = circleCentre;\n  }\n\n  getCenter() {\n    return this.circleCentre;\n  }\n\n  getOneBox() {\n    const startAngle = this.startAngle;\n    const endAngle = this.endAngle;\n    if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {\n      return {\n        minX: -1,\n        maxX: 1,\n        minY: -1,\n        maxY: 1\n      };\n    }\n    const xs = [ 0, Math.cos(startAngle), Math.cos(endAngle) ];\n    const ys = [ 0, Math.sin(startAngle), Math.sin(endAngle) ];\n\n    for (let i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {\n      xs.push(Math.cos(i));\n      ys.push(Math.sin(i));\n    }\n\n    return {\n      minX: Math.min.apply(Math, xs),\n      maxX: Math.max.apply(Math, xs),\n      minY: Math.min.apply(Math, ys),\n      maxY: Math.max.apply(Math, ys)\n    };\n  }\n\n  getRadius() {\n    return this.radius;\n  }\n\n  convertPoint(point) {\n    const center = this.getCenter();\n    let x = this.isTransposed ? point.y : point.x;\n    let y = this.isTransposed ? point.x : point.y;\n\n    x = this.convertDim(x, 'x');\n    y = this.convertDim(y, 'y');\n\n    return {\n      x: center.x + Math.cos(x) * y,\n      y: center.y + Math.sin(x) * y\n    };\n  }\n\n  invertPoint(point) {\n    const center = this.getCenter();\n    const vPoint = [ point.x - center.x, point.y - center.y ];\n    const x = this.x;\n    const m = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n    mat3.rotate(m, m, x.start);\n\n    let vStart = [ 1, 0, 0 ];\n    vec3.transformMat3(vStart, vStart, m);\n    vStart = [ vStart[0], vStart[1] ];\n    let angle = vec2.angleTo(vStart, vPoint, x.end < x.start);\n    if (isNumberEqual(angle, Math.PI * 2)) {\n      angle = 0;\n    }\n    const radius = vec2.length(vPoint);\n\n    let xPercent = angle / (x.end - x.start);\n    xPercent = x.end - x.start > 0 ? xPercent : -xPercent;\n\n    const yPercent = this.invertDim(radius, 'y');\n    const rst = {};\n    rst.x = this.isTransposed ? yPercent : xPercent;\n    rst.y = this.isTransposed ? xPercent : yPercent;\n    return rst;\n  }\n}\n\nmodule.exports = Polar;\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","sourceRoot":""}